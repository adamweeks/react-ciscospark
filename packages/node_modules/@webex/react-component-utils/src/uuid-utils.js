import {base64, deconstructHydraId} from '@webex/common';

/**
 * Tests if a string is a UUID
 * @param {String} string
 * @returns {Boolean}
 */
export function isUuid(string) {
  const uuidRegExp = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

  return uuidRegExp.test(string);
}


/**
 * Takes a Conversation URL and returns the Uuid
 * @param {String} convoUrl
 * @returns {String|Boolean}
 */
export function getConvoIdFromUrl(convoUrl) {
  const id = convoUrl.split('/').pop();

  if (isUuid(id)) {
    return id;
  }

  return false;
}

/**
 * @typedef {object} DeconstructedId
 * @param {string} [id] - id of the object destructed
 * @param {string} [cluster] - cluster location of the object destructed
 * @param {string} [type] - type of object destructed
 */
/**
 * Validates a string as a UUID or a hydra encoded UUID
 * @param {String} string
 * @returns {DeconstructedId} empty object if not a valid input
 */
export function validateAndDecodeId(string) {
  if (!(string && string.length)) {
    return {};
  }

  if (isUuid(string)) {
    return {
      id: string
    };
  }

  // Check for base 64 encoding
  try {
    const idParts = deconstructHydraId(string);

    if (isUuid(idParts.id)) {
      return idParts;
    }
  }
  catch (e) {
    if (e.name !== 'InvalidCharacterError') {
      throw e;
    }
  }

  return {};
}

/**
 * Constructs a hydra id for a given uuid and type
 *
 * @export
 * @param {string} type one of PEOPLE, TEAM, ROOM
 * @param {any} id
 * @returns {string}
 */
export function constructHydraId(type, id) {
  return base64.encode(`ciscospark://us/${type.toUpperCase()}/${id}`);
}

/**
 * Deconstructs a hydra id and provides the uuid
 *
 * @export
 * @param {String} id
 * @returns {object} hydra
 * @returns {String} hydra.id
 * @returns {String} hydra.type
 * @returns {String} hydra.cluster
 */
export {deconstructHydraId};

export const hydraTypes = {
  MESSAGE: 'MESSAGE',
  PEOPLE: 'PEOPLE',
  ROOM: 'ROOM',
  TEAM: 'TEAM'
};
