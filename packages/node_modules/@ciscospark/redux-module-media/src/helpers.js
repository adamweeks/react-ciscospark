/**
 * Constructs a call state with properties the widget uses
 *
 * @export
 * @param {any} call
 * @param {Error} rawError
 * @returns {object}
 */
export function constructCallState(call, rawError) {
  let activeParticipantsCount,
    connected,
    error,
    isInitiated,
    remoteAudioStream,
    remoteVideoStream,
    ringing;

  const {
    remoteAudioMuted,
    remoteVideoMuted
  } = call;

  try {
    if (call && call.remoteMediaStream && call.remoteMediaStream.getAudioTracks) {
      remoteAudioStream = new MediaStream(call.remoteMediaStream.getAudioTracks());
    }
    if (call && call.remoteMediaStream && call.remoteMediaStream.getVideoTracks) {
      remoteVideoStream = new MediaStream(call.remoteMediaStream.getVideoTracks());
    }

    // Ringing means we are calling out to 1:1 and the party hasn't answered
    ringing = call.remoteMember && call.remoteMember.state === 'notified';

    // Connected means both parties are active on a 1:1 or joined in group
    if (typeof call.isCall === 'boolean') {
      if (call.isCall) {
        isInitiated = !!call.locus;
        connected = !!call.remoteMember && call.remoteMember.state === 'connected' && !!call.joinedOnThisDevice;
      }
      else {
        // Group calls are immediately initiated
        isInitiated = true;
        connected = !!call.joinedOnThisDevice;
      }
    }
    else {
      isInitiated = false;
      connected = false;
    }

    activeParticipantsCount = call.memberships.filter((m) => m.state === 'connected').length;

    if (rawError) {
      error = {
        name: rawError.name,
        message: rawError.message
      };
    }
  }
  catch (e) {
    // Do nothing
  }
  return {
    activeParticipantsCount,
    error,
    state: call.state,
    isCall: call.isCall,
    isInitiated,
    direction: call.direction,
    joinedOnThisDevice: call.joinedOnThisDevice,
    connected,
    ringing,
    receivingAudio: call.receivingAudio,
    receivingVideo: call.receivingVideo,
    sendingAudio: call.sendingAudio,
    sendingVideo: call.sendingVideo,
    remoteMediaStream: call.remoteMediaStream,
    localMediaStream: call.localMediaStream,
    remoteAudioMuted,
    remoteVideoMuted,
    remoteAudioStream,
    remoteVideoStream
  };
}

export function releaseCamera(mediaStream) {
  return mediaStream.getTracks().forEach((track) => track.stop());
}
