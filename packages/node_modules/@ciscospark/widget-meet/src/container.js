import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {bindActionCreators} from 'redux';
import {connect} from 'react-redux';
import classNames from 'classnames';
import {autobind} from 'core-decorators';
import {intlShape, injectIntl} from 'react-intl';
import {compose} from 'recompose';
import {
  acceptIncomingCall,
  placeCall,
  declineIncomingCall,
  listenForIncomingCalls,
  hangupCall,
  checkWebRTCSupport
} from '@ciscospark/redux-module-media';
import LoadingScreen from '@ciscospark/react-component-loading-screen';
import SparkLogo from '@ciscospark/react-component-spark-logo';
import Notifications, {
  NOTIFICATION_TYPE_OTHER,
  createNotification
} from '@ciscospark/react-container-notifications';
import Ringtone, {
  RINGTONE_TYPE_RINGBACK,
  RINGTONE_TYPE_INCOMING
} from '@ciscospark/react-component-ringtone';
import {connectToMercury} from '@ciscospark/redux-module-mercury';
import {addError, removeError} from '@ciscospark/redux-module-errors';
import IncomingCall from '@ciscospark/react-component-incoming-call';
import {constructHydraId, isUuid} from '@ciscospark/react-component-utils';

import InactiveCall from './components/call-inactive';
import ActiveCall from './components/call-active';
import messages from './messages';
import {
  updateLocalVideoPosition,
  updateWidgetStatus
} from './actions';
import styles from './styles.css';
import getMeetWidgetProps from './selector';
import enhancers from './enhancers';
import {
  eventNames as defaultEventNames,
  constructCallEventData
} from './events';


const injectedPropTypes = {
  intl: intlShape.isRequired,
  avatarImage: PropTypes.string,
  displayName: PropTypes.string,
  conversation: PropTypes.object.isRequired,
  conversationId: PropTypes.string,
  call: PropTypes.object,
  callInstance: PropTypes.object,
  callIsActive: PropTypes.bool,
  callIsIncoming: PropTypes.bool,
  callIsRinging: PropTypes.bool,
  callState: PropTypes.object,
  hasCheckedWebRTCSupport: PropTypes.bool,
  isWebRTCSupported: PropTypes.bool,
  media: PropTypes.object.isRequired,
  users: PropTypes.object.isRequired,
  sparkInstance: PropTypes.object.isRequired,
  widgetMeet: PropTypes.object.isRequired,
  acceptIncomingCall: PropTypes.func.isRequired,
  addError: PropTypes.func.isRequired,
  connectToMercury: PropTypes.func.isRequired,
  createNotification: PropTypes.func.isRequired,
  declineIncomingCall: PropTypes.func.isRequired,
  hangupCall: PropTypes.func.isRequired,
  listenForIncomingCalls: PropTypes.func.isRequired,
  placeCall: PropTypes.func.isRequired,
  removeError: PropTypes.func.isRequired
};

export const ownPropTypes = {
  muteNotifications: PropTypes.bool,
  onEvent: PropTypes.func,
  startCall: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.bool
  ]),
  spaceId: PropTypes.string,
  toPersonEmail: PropTypes.string,
  toPersonId: PropTypes.string,
  eventNames: PropTypes.object
};


export class MeetWidget extends Component {
  @autobind
  static setup(props) {
    const {
      locusUrl,
      media,
      mercury,
      sparkInstance
    } = props;

    if (!media.getIn(['status', 'isListening']) && locusUrl) {
      props.listenForIncomingCalls(sparkInstance, locusUrl);
    }

    // Setup Web Sockets
    if (!mercury.getIn(['status', 'hasConnected'])
      && !mercury.getIn(['status', 'isConnecting'])
      && !mercury.getIn(['status', 'isConnected'])
      && sparkInstance.internal.device.registered) {
      props.connectToMercury(sparkInstance);
    }
  }

  static findClosestPosition(node, position) {
    const parent = node.offsetParent;
    const {x, y} = position;
    const nodeHeight = node.offsetHeight;
    const nodeWidth = node.offsetWidth;
    const parentHeight = parent.offsetHeight;
    const parentWidth = parent.offsetWidth;

    const x2 = (parentWidth - nodeWidth) / 2;
    const x3 = parentWidth - nodeWidth;
    const y2 = (parentHeight - nodeHeight) / 2;

    const snapTransform = [
      {x: -x3, y: 0}, {x: -x2, y: 0}, {x: 0, y: 0},
      {x: -x3, y: y2}, {x: 0, y: y2}
    ];

    const distances = snapTransform.map((val) => {
      const dx = x - val.x;
      const dy = y - val.y;
      return Math.sqrt(dx * dx + dy * dy);
    });

    return snapTransform[distances.indexOf(Math.min(...distances))];
  }

  componentDidMount() {
    const {
      hasCheckedWebRTCSupport,
      isWebRTCSupported,
      sparkInstance
    } = this.props;

    this.eventNames = Object.assign({}, defaultEventNames, this.props.eventNames);

    if (!hasCheckedWebRTCSupport) {
      this.props.checkWebRTCSupport(sparkInstance);
    }
    if (isWebRTCSupported) {
      MeetWidget.setup(this.props);
    }
  }

  componentWillReceiveProps(nextProps) {
    if (nextProps.isWebRTCSupported) {
      MeetWidget.setup(nextProps);

      const {
        users,
        conversationId,
        call,
        displayName,
        startCall,
        widgetMeet,
        callFrom,
        callIsIncoming,
        callInstance,
        callState
      } = nextProps;

      const currentUser = users.get('currentUser');
      const activeCall = call;
      const prevCallIsIncoming = this.props.callIsIncoming;
      const prevCallState = this.props.callState;
      if (activeCall) {
        // Check if this is a new initiated call
        if (callState.isInitiated && (!prevCallState || !prevCallState.isInitiated)) {
          // Is this an incoming call?
          if (callIsIncoming && !prevCallIsIncoming) {
            this.incomingCallNotification(activeCall, displayName);
          }
          // Emit the event
          this.handleEvent(
            this.eventNames.CALLS_CREATED,
            constructCallEventData(callInstance, callFrom, conversationId)
          );
        }

        if (callState.connected && !prevCallState.connected) {
          // New call is connected, emit event
          this.handleEvent(
            this.eventNames.CALLS_CONNECTED,
            constructCallEventData(callInstance, callFrom, conversationId)
          );
        }

        if (callState.error && !prevCallState.error) {
          // Call has an error
          this.catchCallError(callState.error);
          this.handleHangup();
        }
      }


      if (this.props.locusUrl && currentUser && !widgetMeet.getIn(['status', 'hasOpenWithCall'])
        && (startCall === true || startCall === '' || startCall === 'true')) {
        nextProps.updateWidgetStatus({hasOpenWithCall: true});
        this.handleCall();
      }
    }
  }

  shouldComponentUpdate(nextProps) {
    const {props} = this;
    return nextProps.media !== props.media
      || nextProps.avatarImage !== props.avatarImage
      || nextProps.widgetMeet !== props.widgetMeet;
  }

  componentWillUnmount() {
    if (this.props.callIsActive) {
      this.handleHangup();
    }
  }

  /**
   * Event handler in case one isn't provided
   * @param {string} name
   * @param {object} data
   * @returns {undfined}
   */
  @autobind
  handleEvent(name, data) {
    const {onEvent} = this.props;
    if (typeof onEvent === 'function') {
      this.props.onEvent(name, data);
    }
  }

  @autobind
  handleCall() {
    const {props} = this;
    const {
      toPerson,
      toPersonEmail,
      toPersonId,
      spaceId,
      sparkInstance,
      locusUrl
    } = this.props;
    let destination = toPersonId || toPersonEmail || toPerson;
    if (spaceId) {
      if (isUuid(spaceId)) {
        destination = constructHydraId('ROOM', spaceId);
      }
      else {
        destination = spaceId;
      }
    }
    props.placeCall({
      destination,
      locusUrl
    }, sparkInstance)
      .catch(this.catchCallError);
  }

  @autobind
  handleHangup() {
    const {props} = this;
    const {
      callInstance,
      conversationId,
      locusUrl,
      users
    } = props;
    const currentUser = users.get('currentUser');

    props.hangupCall({call: callInstance, locusUrl}).then(() => {
      this.handleEvent(
        this.eventNames.CALLS_DISCONNECTED,
        constructCallEventData(callInstance, currentUser, conversationId)
      );
    });
  }

  @autobind
  handleStartSendingAudio() {
    this.props.callInstance.startSendingAudio();
  }

  @autobind
  handleStartSendingVideo() {
    this.props.callInstance.startSendingVideo();
  }

  @autobind
  handleStopSendingAudio() {
    this.props.callInstance.stopSendingAudio();
  }

  @autobind
  handleStopSendingVideo() {
    this.props.callInstance.stopSendingVideo();
  }

  @autobind
  handleAnswer() {
    const {callInstance, locusUrl} = this.props;
    this.props.acceptIncomingCall(callInstance, locusUrl).catch(this.catchCallError);
  }

  @autobind
  handleDecline() {
    const {callInstance} = this.props;
    this.props.declineIncomingCall(callInstance);
  }

  @autobind
  handleLocalVideoDragStop(e, data) {
    const {node, x, y} = data;
    const closest = MeetWidget.findClosestPosition(node, {x, y});
    this.props.updateLocalVideoPosition(closest);
  }

  @autobind
  catchCallError(e) {
    const {props} = this;
    const callErrorId = 'spark.call';
    const {formatMessage} = props.intl;
    const actionTitle = formatMessage(messages.okButtonLabel);
    let displayTitle;
    let displaySubtitle;
    switch (e.name) {
      case 'DevicesNotFoundError':
        displayTitle = formatMessage(messages.callErrorDeviceNotFound);
        break;
      case 'NotAllowedError':
        displayTitle = formatMessage(messages.callErrorNotAllowed);
        break;
      case 'SecurityError':
        displayTitle = formatMessage(messages.callErrorSecurity);
        break;
      default:
        displayTitle = formatMessage(messages.callErrorUnknownMessage);
        displaySubtitle = `(${e.name} ${e.message})`;
    }
    props.addError({
      actionTitle,
      code: e.name,
      id: callErrorId,
      displayTitle,
      displaySubtitle,
      onAction: () => props.removeError(callErrorId),
      temporary: true
    });
  }

  incomingCallNotification(incomingCall, fromPersonName) {
    const {
      intl,
      avatarImage
    } = this.props;
    const {formatMessage} = intl;
    const details = {
      username: fromPersonName,
      message: formatMessage(messages.incomingCallMessage),
      avatar: avatarImage
    };
    this.props.createNotification(incomingCall.locusUrl, NOTIFICATION_TYPE_OTHER, details);
  }

  render() {
    const {
      call,
      callIsActive,
      callIsIncoming,
      callIsRinging,
      callState,
      intl,
      isWebRTCSupported,
      avatarImage,
      displayName,
      widgetMeet
    } = this.props;
    const {formatMessage} = intl;

    if (isWebRTCSupported && (avatarImage || displayName)) {
      // If we have a call object
      if (call) {
        // Is the call active?
        if (callIsActive) {
          const {
            handleHangup,
            handleLocalVideoDragStop,
            handleStartSendingAudio,
            handleStartSendingVideo,
            handleStopSendingAudio,
            handleStopSendingVideo
          } = this;

          const {
            remoteAudioStream,
            remoteMediaStream,
            remoteVideoStream,
            localMediaStream
          } = callState;

          return (
            <div className={classNames(styles.meetWidgetContainer, 'meet-widget-container')}>
              <ActiveCall
                avatarImage={avatarImage}
                callState={callState}
                displayName={displayName}
                localMediaStream={localMediaStream}
                localVideoPosition={widgetMeet.get('localVideoPosition')}
                onHangupClick={handleHangup}
                onLocalVideoDragStop={handleLocalVideoDragStop}
                onStartSendingAudio={handleStartSendingAudio}
                onStartSendingVideo={handleStartSendingVideo}
                onStopSendingAudio={handleStopSendingAudio}
                onStopSendingVideo={handleStopSendingVideo}
                remoteAudioStream={remoteAudioStream}
                remoteMediaStream={remoteMediaStream}
                remoteVideoStream={remoteVideoStream}
              />
              <Ringtone play={callIsRinging} type={RINGTONE_TYPE_RINGBACK} />
            </div>
          );
        }

        // Is this an incoming call?
        if (callIsIncoming) {
          const {
            handleAnswer,
            handleDecline
          } = this;

          return (
            <div className={classNames(styles.meetWidgetContainer, 'meet-widget-container')}>
              <IncomingCall
                answerButtonLabel={formatMessage(messages.answerButtonLabel)}
                avatarImage={avatarImage}
                declineButtonLabel={formatMessage(messages.declineButtonLabel)}
                displayName={displayName}
                incomingCallMessage={formatMessage(messages.incomingCallMessage)}
                onAnswerClick={handleAnswer}
                onDeclineClick={handleDecline}
              />
              <Ringtone play type={RINGTONE_TYPE_INCOMING} />
            </div>
          );
        }
      }


      return (
        <div className={classNames(styles.meetWidgetContainer, 'meet-widget-container')}>
          <InactiveCall
            avatarImage={avatarImage}
            callButtonLabel={formatMessage(messages.callButtonLabel)}
            displayName={displayName}
            onCallClick={this.handleCall}
          />
          <Notifications onEvent={this.handleEvent} />
        </div>
      );
    }

    if (isWebRTCSupported === false) {
      return (
        <div className={classNames(styles.meetWidgetContainer, styles.noWebRtc, 'meet-widget-container')}>
          <div className={styles.noWebRtcLogo}><SparkLogo /></div>
          <div className={styles.noWebRtcMessage}>
            <p>{formatMessage(messages.noWebRTCBrowserSupportMessage)}</p>
            <p>{formatMessage(messages.useSupportedBrowserMessage)}</p>
          </div>
        </div>
      );
    }

    return <LoadingScreen />;
  }
}


MeetWidget.propTypes = {
  ...ownPropTypes,
  ...injectedPropTypes
};


export default compose(
  connect(
    getMeetWidgetProps,
    (dispatch) => bindActionCreators({
      acceptIncomingCall,
      addError,
      connectToMercury,
      createNotification,
      declineIncomingCall,
      hangupCall,
      listenForIncomingCalls,
      placeCall,
      removeError,
      updateLocalVideoPosition,
      updateWidgetStatus,
      checkWebRTCSupport
    }, dispatch)
  ),
  injectIntl,
  ...enhancers
)(MeetWidget);
